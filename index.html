<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Simple WebAR</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        overflow: hidden;
        font-family: Arial, sans-serif;
        background: black;
      }
      #overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      #start-button {
        padding: 20px 40px;
        font-size: 18px;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
      }
      #instructions {
        color: white;
        text-align: center;
        padding: 20px;
        max-width: 80%;
      }
      #video {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      #canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      #info {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 15px 25px;
        border-radius: 25px;
        z-index: 1000;
        font-size: 16px;
        text-align: center;
        max-width: 90%;
      }
      .hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <div id="instructions">
        <h2>ðŸŽ­ Simple AR Experience</h2>
        <p>Tap anywhere to place a dancing character that stays in the real world!</p>
      </div>
      <button id="start-button">Start AR</button>
    </div>

    <video id="video" playsinline autoplay muted class="hidden"></video>
    <canvas id="canvas" class="hidden"></canvas>
    <div id="info" class="hidden">ðŸ‘† Tap anywhere to place character</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
      const video = document.getElementById('video');
      const canvas = document.getElementById('canvas');
      const info = document.getElementById('info');
      
      let scene, camera, renderer;
      let characters = [];
      let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
      let initialOrientation = null;
      let isARActive = false;
      let cameraGroup;

      // Handle device orientation
      if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', (e) => {
          deviceOrientation.alpha = e.alpha || 0;
          deviceOrientation.beta = e.beta || 0;
          deviceOrientation.gamma = e.gamma || 0;
          
          if (!initialOrientation) {
            initialOrientation = { ...deviceOrientation };
          }
        });
      }

      document.getElementById('start-button').addEventListener('click', async function() {
        try {
          // Request device orientation permission on iOS
          if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            await DeviceOrientationEvent.requestPermission();
          }

          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
              facingMode: 'environment',
              width: { ideal: 1280 },
              height: { ideal: 720 }
            } 
          });
          
          video.srcObject = stream;
          await video.play();
          
          document.getElementById('overlay').classList.add('hidden');
          video.classList.remove('hidden');
          canvas.classList.remove('hidden');
          info.classList.remove('hidden');
          
          initThreeJS();
          
        } catch (error) {
          alert('Error: ' + error.message + '\n\nPlease allow camera and motion sensors.');
        }
      });

      function initThreeJS() {
        scene = new THREE.Scene();
        
        // Create camera group to handle orientation
        cameraGroup = new THREE.Group();
        scene.add(cameraGroup);
        
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 0);
        cameraGroup.add(camera);
        
        renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // Lights attached to camera so they move with you
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        cameraGroup.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        cameraGroup.add(directionalLight);
        
        isARActive = true;
        animate();
      }

      function createCharacter() {
        const character = new THREE.Group();
        const scale = 0.25; // Make 4x smaller (about 20cm tall)
        
        // Body
        const bodyGeom = new THREE.CylinderGeometry(0.15 * scale, 0.2 * scale, 0.5 * scale, 8);
        const bodyMat = new THREE.MeshPhongMaterial({ color: 0x4CAF50 });
        const body = new THREE.Mesh(bodyGeom, bodyMat);
        body.position.y = 0.25 * scale;
        character.add(body);
        
        // Head
        const headGeom = new THREE.SphereGeometry(0.15 * scale, 16, 16);
        const headMat = new THREE.MeshPhongMaterial({ color: 0xFFD700 });
        const head = new THREE.Mesh(headGeom, headMat);
        head.position.y = 0.65 * scale;
        character.add(head);
        
        // Eyes
        const eyeGeom = new THREE.SphereGeometry(0.04 * scale, 8, 8);
        const eyeMat = new THREE.MeshPhongMaterial({ color: 0x000000 });
        const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
        leftEye.position.set(-0.06 * scale, 0.68 * scale, 0.13 * scale);
        character.add(leftEye);
        const rightEye = leftEye.clone();
        rightEye.position.x = 0.06 * scale;
        character.add(rightEye);
        
        // Arms
        const armGeom = new THREE.CylinderGeometry(0.05 * scale, 0.04 * scale, 0.4 * scale, 8);
        const armMat = new THREE.MeshPhongMaterial({ color: 0x4CAF50 });
        const leftArm = new THREE.Mesh(armGeom, armMat);
        leftArm.position.set(-0.25 * scale, 0.25 * scale, 0);
        leftArm.rotation.z = 0.5;
        character.add(leftArm);
        
        const rightArm = new THREE.Mesh(armGeom, armMat);
        rightArm.position.set(0.25 * scale, 0.25 * scale, 0);
        rightArm.rotation.z = -0.5;
        character.add(rightArm);
        
        // Legs
        const legGeom = new THREE.CylinderGeometry(0.06 * scale, 0.05 * scale, 0.4 * scale, 8);
        const legMat = new THREE.MeshPhongMaterial({ color: 0x2196F3 });
        const leftLeg = new THREE.Mesh(legGeom, legMat);
        leftLeg.position.set(-0.1 * scale, -0.2 * scale, 0);
        character.add(leftLeg);
        
        const rightLeg = new THREE.Mesh(legGeom, legMat);
        rightLeg.position.set(0.1 * scale, -0.2 * scale, 0);
        character.add(rightLeg);
        
        // Store references for animation
        character.userData = {
          leftArm: leftArm,
          rightArm: rightArm,
          leftLeg: leftLeg,
          rightLeg: rightLeg,
          head: head,
          startTime: Date.now(),
          baseY: 0,
          scale: scale
        };
        
        return character;
      }

      function placeCharacter(touchX, touchY) {
        const character = createCharacter();
        
        // Convert screen coordinates to normalized device coordinates (-1 to +1)
        const x = (touchX / window.innerWidth) * 2 - 1;
        const y = -(touchY / window.innerHeight) * 2 + 1;
        
        // Create raycaster from tap position
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
        
        // Place character 1.5 meters in front of where you're looking in world space
        const distance = 1.5;
        
        // Get the ray direction in world space
        const direction = raycaster.ray.direction.clone();
        direction.applyQuaternion(cameraGroup.quaternion);
        
        // Calculate position from camera group's position
        const position = cameraGroup.position.clone().add(direction.multiplyScalar(distance));
        
        character.position.copy(position);
        character.userData.baseY = position.y;
        
        // Make character face camera
        character.lookAt(cameraGroup.position);
        character.rotation.y += Math.PI;
        
        // Add to scene (not cameraGroup) so it stays in world space
        scene.add(character);
        characters.push(character);
        
        info.innerHTML = `ðŸŽ‰ Character ${characters.length} placed! Tap to add more`;
        
        // Add sparkle effect
        createSparkles(character.position);
      }

      function createSparkles(position) {
        const sparkleGeom = new THREE.SphereGeometry(0.02, 4, 4);
        
        for (let i = 0; i < 15; i++) {
          const color = Math.random() > 0.5 ? 0xFFD700 : 0xFF69B4;
          const sparkleMat = new THREE.MeshBasicMaterial({ color: color });
          const sparkle = new THREE.Mesh(sparkleGeom, sparkleMat);
          
          sparkle.position.copy(position);
          sparkle.userData.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.05,
            Math.random() * 0.08,
            (Math.random() - 0.5) * 0.05
          );
          sparkle.userData.life = 1.0;
          
          scene.add(sparkle);
          characters.push(sparkle);
        }
      }

      function animateCharacters() {
        characters = characters.filter(obj => {
          // Sparkle animation
          if (obj.userData.life !== undefined) {
            obj.position.add(obj.userData.velocity);
            obj.userData.velocity.y -= 0.002;
            obj.userData.life -= 0.015;
            obj.material.opacity = obj.userData.life;
            obj.material.transparent = true;
            
            if (obj.userData.life <= 0) {
              scene.remove(obj);
              return false;
            }
            return true;
          }
          
          // Character animation
          if (obj.userData.startTime) {
            const t = (Date.now() - obj.userData.startTime) / 1000;
            const scale = obj.userData.scale;
            
            // Bounce
            obj.position.y = obj.userData.baseY + Math.abs(Math.sin(t * 3)) * 0.1 * scale;
            
            // Rotate
            obj.rotation.y += 0.01;
            
            // Arms
            obj.userData.leftArm.rotation.z = 0.5 + Math.sin(t * 4) * 0.6;
            obj.userData.rightArm.rotation.z = -0.5 - Math.sin(t * 4) * 0.6;
            
            // Legs
            obj.userData.leftLeg.rotation.x = Math.sin(t * 4) * 0.3;
            obj.userData.rightLeg.rotation.x = -Math.sin(t * 4) * 0.3;
            
            // Head bob
            obj.userData.head.rotation.z = Math.sin(t * 3) * 0.15;
          }
          
          return true;
        });
      }

      function updateCameraOrientation() {
        if (!initialOrientation) return;
        
        const yaw = (deviceOrientation.alpha - initialOrientation.alpha) * Math.PI / 180;
        const pitch = (deviceOrientation.beta - initialOrientation.beta) * Math.PI / 180;
        
        // Rotate the camera group, not individual camera
        cameraGroup.rotation.set(pitch * 0.5, yaw, 0, 'YXZ');
      }

      function animate() {
        if (!isARActive) return;
        requestAnimationFrame(animate);
        
        updateCameraOrientation();
        animateCharacters();
        
        renderer.render(scene, camera);
      }

      // Tap to place
      canvas.addEventListener('click', (e) => {
        if (isARActive) {
          e.preventDefault();
          placeCharacter(e.clientX, e.clientY);
        }
      });

      canvas.addEventListener('touchstart', (e) => {
        if (isARActive && e.touches.length > 0) {
          e.preventDefault();
          placeCharacter(e.touches[0].clientX, e.touches[0].clientY);
        }
      });

      // Handle resize
      window.addEventListener('resize', () => {
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });
    </script>
  </body>
</html>
